import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import styled from '@emotion/styled'; // eslint-disable-next-line no-restricted-imports

import { format, isValid, lastDayOfMonth, parse } from 'date-fns';
import pick from 'lodash/pick';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import Calendar from '@atlaskit/calendar';
import CalendarIcon from '@atlaskit/icon/glyph/calendar';
import { createLocalizationProvider } from '@atlaskit/locale';
import Select, { mergeStyles } from '@atlaskit/select';
import { B100, N20 } from '@atlaskit/theme/colors';
import { borderRadius, gridSize, layers } from '@atlaskit/theme/constants';
import { e200 } from '@atlaskit/theme/elevation';
import { defaultDateFormat, EmptyClearIndicator, padToTwo, placeholderDatetime } from '../internal';
import FixedLayer from '../internal/FixedLayer';
const packageName = "@atlaskit/datetime-picker";
const packageVersion = "10.2.1";
/* eslint-disable react/no-unused-prop-types */

function getDateObj(date) {
  return {
    day: date.getDate(),
    month: date.getMonth() + 1,
    year: date.getFullYear()
  };
}

function getValidDate(iso) {
  const date = parse(iso);
  return isValid(date) ? getDateObj(date) : {};
}

const StyledMenu = styled.div`
  background-color: ${N20};
  border-radius: ${borderRadius()}px;
  z-index: ${layers.dialog};
  ${e200()};
`;

const Menu = ({
  selectProps,
  innerProps
}) => /*#__PURE__*/React.createElement(FixedLayer, {
  inputValue: selectProps.inputValue,
  containerRef: selectProps.calendarContainerRef,
  content: /*#__PURE__*/React.createElement(StyledMenu, innerProps, /*#__PURE__*/React.createElement(Calendar, _extends({}, getValidDate(selectProps.calendarValue), getValidDate(selectProps.calendarView), {
    disabled: selectProps.calendarDisabled,
    onChange: selectProps.onCalendarChange,
    onSelect: selectProps.onCalendarSelect,
    calendarRef: selectProps.calendarRef,
    selected: [selectProps.calendarValue],
    locale: selectProps.calendarLocale,
    testId: selectProps.testId && `${selectProps.testId}--calendar`,
    weekStartDay: selectProps.calendarWeekStartDay
  }))),
  testId: selectProps.testId
});

const datePickerDefaultProps = {
  appearance: 'default',
  autoFocus: false,
  defaultIsOpen: false,
  defaultValue: '',
  disabled: [],
  hideIcon: false,
  icon: CalendarIcon,
  id: '',
  innerProps: {},
  isDisabled: false,
  isInvalid: false,
  name: '',
  onBlur: event => {},
  onChange: value => {},
  onFocus: event => {},
  selectProps: {},
  spacing: 'default',
  locale: 'en-US' // Not including a default prop for value as it will
  // Make the component a controlled component

};

class DatePicker extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "calendarRef", null);

    _defineProperty(this, "containerRef", null);

    _defineProperty(this, "getSafeState", () => {
      return { ...this.state,
        ...pick(this.props, ['value', 'isOpen']),
        ...pick(this.props.selectProps, ['inputValue'])
      };
    });

    _defineProperty(this, "isDateDisabled", date => {
      return this.props.disabled.indexOf(date) > -1;
    });

    _defineProperty(this, "onCalendarChange", ({
      iso
    }) => {
      const [year, month, date] = iso.split('-');
      let newIso = iso;
      const parsedDate = parseInt(date, 10);
      const parsedMonth = parseInt(month, 10);
      const parsedYear = parseInt(year, 10);
      const lastDayInMonth = lastDayOfMonth(new Date(parsedYear, parsedMonth - 1)).getDate();

      if (lastDayInMonth < parsedDate) {
        newIso = `${year}-${padToTwo(parsedMonth)}-${padToTwo(lastDayInMonth)}`;
      } else {
        newIso = `${year}-${padToTwo(parsedMonth)}-${padToTwo(parsedDate)}`;
      }

      this.setState({
        view: newIso
      });
    });

    _defineProperty(this, "onCalendarSelect", ({
      iso
    }) => {
      this.setState({
        inputValue: '',
        isOpen: false,
        selectedValue: iso,
        view: iso,
        value: iso
      });
      this.props.onChange(iso);
    });

    _defineProperty(this, "onInputClick", () => {
      if (!this.getSafeState().isOpen) {
        this.setState({
          isOpen: true
        });
      }
    });

    _defineProperty(this, "onSelectBlur", event => {
      if (this.getSafeState().clearingFromIcon) {
        // Don't close menu if blurring after the user has clicked clear
        this.setState({
          clearingFromIcon: false
        });
      } else {
        this.setState({
          isOpen: false
        });
      }

      this.props.onBlur(event);
    });

    _defineProperty(this, "onSelectFocus", event => {
      const {
        clearingFromIcon,
        value
      } = this.getSafeState();

      if (clearingFromIcon) {
        // Don't open menu if focussing after the user has clicked clear
        this.setState({
          clearingFromIcon: false
        });
      } else {
        this.setState({
          isOpen: true,
          view: value
        });
      }

      this.props.onFocus(event);
    });

    _defineProperty(this, "onSelectInput", event => {
      const value = event.target.value;

      if (value) {
        const parsed = this.parseDate(value); // Only try to set the date if we have month & day

        if (parsed && isValid(parsed)) {
          // We format the parsed date to YYYY-MM-DD here because
          // this is the format expected by the @atlaskit/calendar component
          this.setState({
            view: format(parsed, 'YYYY-MM-DD')
          });
        }
      }

      this.setState({
        isOpen: true
      });
    });

    _defineProperty(this, "onSelectKeyDown", event => {
      const {
        view,
        selectedValue
      } = this.getSafeState();
      const keyPressed = event.key.toLowerCase();

      switch (keyPressed) {
        case 'arrowup':
        case 'arrowdown':
          if (this.calendarRef) {
            event.preventDefault();
            const key = keyPressed === 'arrowup' ? 'up' : 'down';
            this.calendarRef.navigate(key);
          }

          this.setState({
            isOpen: true
          });
          break;

        case 'arrowleft':
        case 'arrowright':
          if (this.calendarRef) {
            event.preventDefault();
            const key = keyPressed === 'arrowleft' ? 'left' : 'right';
            this.calendarRef.navigate(key);
          }

          break;

        case 'escape':
        case 'tab':
          this.setState({
            isOpen: false
          });
          break;

        case 'backspace':
        case 'delete':
          if (selectedValue && event.target instanceof HTMLInputElement && event.target.value.length < 1) {
            // If being cleared from keyboard, don't change behaviour
            this.setState({
              clearingFromIcon: false
            });
          }

          break;

        case 'enter':
          if (!this.isDateDisabled(view)) {
            this.setState({
              inputValue: '',
              isOpen: false,
              selectedValue: view,
              value: view,
              view
            });
            this.props.onChange(view);
          }

          break;

        default:
          break;
      }
    });

    _defineProperty(this, "onClear", () => {
      let changedState = {
        selectedValue: '',
        value: '',
        view: this.props.defaultValue || format(new Date(), 'YYYY-MM-DD')
      };

      if (!this.props.hideIcon) {
        changedState = { ...changedState,
          clearingFromIcon: true
        };
      }

      this.setState(changedState);
      this.props.onChange('');
    });

    _defineProperty(this, "onSelectChange", (value, action) => {
      // Used for native clear event in React Select
      // Triggered when clicking ClearIndicator or backspace with no value
      if (action.action === 'clear') {
        this.onClear();
      }
    });

    _defineProperty(this, "refCalendar", ref => {
      this.calendarRef = ref;
    });

    _defineProperty(this, "handleInputChange", (inputValue, actionMeta) => {
      const {
        onInputChange
      } = this.props.selectProps;

      if (onInputChange) {
        onInputChange(inputValue, actionMeta);
      }

      this.setState({
        inputValue
      });
    });

    _defineProperty(this, "getContainerRef", ref => {
      const oldRef = this.containerRef;
      this.containerRef = ref; // Cause a re-render if we're getting the container ref for the first time
      // as the layered menu requires it for dimension calculation

      if (oldRef == null && ref != null) {
        this.forceUpdate();
      }
    });

    _defineProperty(this, "getSubtleControlStyles", isOpen => ({
      border: `2px solid ${isOpen ? B100 : `transparent`}`,
      backgroundColor: 'transparent',
      padding: '1px'
    }));

    _defineProperty(this, "parseDate", date => {
      const {
        parseInputValue,
        dateFormat
      } = this.props;

      if (parseInputValue) {
        return parseInputValue(date, dateFormat || defaultDateFormat);
      }

      const {
        l10n
      } = this.getSafeState();
      return l10n.parseDate(date);
    });

    _defineProperty(this, "formatDate", value => {
      const {
        formatDisplayLabel,
        dateFormat
      } = this.props;
      const {
        l10n
      } = this.getSafeState();

      if (formatDisplayLabel) {
        return formatDisplayLabel(value, dateFormat || defaultDateFormat);
      }

      const date = parse(value);

      if (dateFormat) {
        return format(date, dateFormat);
      }

      return l10n.formatDate(date);
    });

    _defineProperty(this, "getPlaceholder", () => {
      const {
        placeholder
      } = this.props;

      if (placeholder) {
        return placeholder;
      }

      const {
        l10n
      } = this.getSafeState();
      return l10n.formatDate(placeholderDatetime);
    });

    const {
      day,
      month: _month,
      year: _year
    } = getDateObj(new Date());
    this.state = {
      isOpen: this.props.defaultIsOpen,
      clearingFromIcon: false,
      inputValue: this.props.selectProps.inputValue,
      selectedValue: this.props.value || this.props.defaultValue,
      value: this.props.defaultValue,
      view: this.props.value || this.props.defaultValue || `${_year}-${padToTwo(_month)}-${padToTwo(day)}`,
      l10n: createLocalizationProvider(this.props.locale)
    };
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.locale !== nextProps.locale) {
      this.setState({
        l10n: createLocalizationProvider(nextProps.locale)
      });
    }
  } // All state needs to be accessed via this function so that the state is mapped from props
  // correctly to allow controlled/uncontrolled usage.


  render() {
    const {
      appearance,
      autoFocus,
      disabled,
      hideIcon,
      icon,
      id,
      innerProps,
      isDisabled,
      isInvalid,
      name,
      selectProps,
      spacing,
      locale,
      testId,
      weekStartDay
    } = this.props;
    const BORDER_WIDTH = 2;
    const ICON_PADDING = 2;
    const {
      value,
      view,
      isOpen,
      inputValue
    } = this.getSafeState();
    const menuIsOpen = isOpen && !isDisabled;
    const showClearIndicator = Boolean((value || inputValue) && !hideIcon);
    const dropDownIcon = appearance === 'subtle' || hideIcon || showClearIndicator ? null : icon;
    const selectComponents = {
      DropdownIndicator: dropDownIcon,
      Menu
    };

    if (!showClearIndicator) {
      selectComponents.ClearIndicator = EmptyClearIndicator;
    }

    const {
      styles: selectStyles = {}
    } = selectProps;
    const controlStyles = appearance === 'subtle' ? this.getSubtleControlStyles(isOpen) : {};
    const disabledStyle = isDisabled ? {
      pointerEvents: 'none'
    } : {};
    const calendarProps = {
      calendarContainerRef: this.containerRef,
      calendarRef: this.refCalendar,
      calendarDisabled: disabled,
      calendarValue: value && format(parse(value), 'YYYY-MM-DD'),
      calendarView: view,
      onCalendarChange: this.onCalendarChange,
      onCalendarSelect: this.onCalendarSelect,
      calendarLocale: locale,
      calendarWeekStartDay: weekStartDay
    };
    return /*#__PURE__*/React.createElement("div", _extends({}, innerProps, {
      role: "presentation",
      onClick: this.onInputClick,
      onInput: this.onSelectInput,
      onKeyDown: this.onSelectKeyDown,
      ref: this.getContainerRef,
      "data-testid": testId && `${testId}--container`
    }), /*#__PURE__*/React.createElement("input", {
      name: name,
      type: "hidden",
      value: value,
      "data-testid": testId && `${testId}--input`
    }), /*#__PURE__*/React.createElement(Select, _extends({
      enableAnimation: false,
      menuIsOpen: menuIsOpen,
      closeMenuOnSelect: true,
      autoFocus: autoFocus,
      instanceId: id,
      isDisabled: isDisabled,
      onBlur: this.onSelectBlur,
      onFocus: this.onSelectFocus,
      inputValue: inputValue,
      onInputChange: this.handleInputChange,
      components: selectComponents,
      onChange: this.onSelectChange,
      styles: mergeStyles(selectStyles, {
        control: base => ({ ...base,
          ...controlStyles,
          ...disabledStyle
        }),
        indicatorsContainer: base => ({ ...base,
          paddingLeft: ICON_PADDING,
          paddingRight: gridSize() - BORDER_WIDTH
        })
      }),
      placeholder: this.getPlaceholder(),
      value: value && {
        label: this.formatDate(value),
        value
      }
    }, selectProps, calendarProps, {
      isClearable: true,
      spacing: spacing,
      validationState: isInvalid ? 'error' : 'default',
      testId: testId
    })));
  }

}

_defineProperty(DatePicker, "defaultProps", datePickerDefaultProps);

export { DatePicker as DatePickerWithoutAnalytics };
export default withAnalyticsContext({
  componentName: 'datePicker',
  packageName,
  packageVersion
})(withAnalyticsEvents({
  onChange: createAndFireEvent('atlaskit')({
    action: 'selectedDate',
    actionSubject: 'datePicker',
    attributes: {
      componentName: 'datePicker',
      packageName,
      packageVersion
    }
  })
})(DatePicker));