{"ast":null,"code":"import { isValid, normalizeDate, toDate } from './utils';\nimport { normalizeLocale } from '../common';\nvar INVALID_DATE = new Date(NaN);\nvar INVARIANT = {\n  year: 1993,\n  month: 2,\n  day: 18\n};\nvar INVARIANT_DATE = toDate(INVARIANT);\nvar FORMAT_EXTRACTOR_REGEX = /(\\d+)[^\\d]+(\\d+)[^\\d]+(\\d+)\\.?/;\nvar DATE_PARSER_REGEX = /(\\d+)[^\\d]*(\\d+)?[^\\d]*(\\d+)?\\.?/; // Internet Explorer returns non-printing characters when formatting a date\n\nvar stripExtras = function stripExtras(str) {\n  return str.replace(/\\u200E/g, '');\n};\n\nvar extractDateParts = function extractDateParts(matchResult) {\n  return matchResult // Get the 3 capture groups\n  .splice(1, 4) // Convert them to numbers\n  .map(function (datePart) {\n    return parseInt(datePart, 10);\n  });\n};\n/**\n * Creates a date parser function for a specific locale. The function will\n * either return a valid Date from the input or an Invalid Date object if the\n * input is invalid.\n *\n * @param locale - A BCP 47 language tag\n * @returns DateParser\n */\n\n\nexport var createDateParser = function createDateParser(locale) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var dateFormatter = Intl.DateTimeFormat(normalizedLocale); // Generate a date string from a hard coded date, this allows us to determine\n  // the year/month/day position for the provided locale.\n\n  var rawDateString = dateFormatter.format(INVARIANT_DATE);\n  var shortDate = stripExtras(rawDateString); // Extract the date pieces from the locale formatted date string\n\n  var formatMatch = shortDate.match(FORMAT_EXTRACTOR_REGEX);\n\n  if (!formatMatch) {\n    throw new Error('Unable to create DateParser');\n  }\n\n  var formatParts = extractDateParts(formatMatch); // Find the year/month/day positions of the locale formatted invariant date\n\n  var yearPosition = formatParts.indexOf(INVARIANT.year);\n  var monthPosition = formatParts.indexOf(INVARIANT.month);\n  var dayPosition = formatParts.indexOf(INVARIANT.day);\n  return function (date) {\n    var dateMatch = stripExtras(date).match(DATE_PARSER_REGEX);\n\n    if (!dateMatch) {\n      return INVALID_DATE;\n    }\n\n    var dateParts = extractDateParts(dateMatch); // Use the previously extracted year/month/day positions to extract each\n    // date piece.\n\n    var extractedDate = {\n      year: dateParts[yearPosition],\n      month: dateParts[monthPosition],\n      day: dateParts[dayPosition]\n    };\n    var normalizedDate = normalizeDate(extractedDate);\n\n    if (!isValid(normalizedDate)) {\n      return INVALID_DATE;\n    }\n\n    return toDate(normalizedDate);\n  };\n};","map":{"version":3,"sources":["/Users/dsmint/restaurantreservation/node_modules/@atlaskit/locale/dist/esm/internal/date-parser/index.js"],"names":["isValid","normalizeDate","toDate","normalizeLocale","INVALID_DATE","Date","NaN","INVARIANT","year","month","day","INVARIANT_DATE","FORMAT_EXTRACTOR_REGEX","DATE_PARSER_REGEX","stripExtras","str","replace","extractDateParts","matchResult","splice","map","datePart","parseInt","createDateParser","locale","normalizedLocale","dateFormatter","Intl","DateTimeFormat","rawDateString","format","shortDate","formatMatch","match","Error","formatParts","yearPosition","indexOf","monthPosition","dayPosition","date","dateMatch","dateParts","extractedDate","normalizedDate"],"mappings":"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","sourcesContent":["import { isValid, normalizeDate, toDate } from './utils';\nimport { normalizeLocale } from '../common';\nvar INVALID_DATE = new Date(NaN);\nvar INVARIANT = {\n  year: 1993,\n  month: 2,\n  day: 18\n};\nvar INVARIANT_DATE = toDate(INVARIANT);\nvar FORMAT_EXTRACTOR_REGEX = /(\\d+)[^\\d]+(\\d+)[^\\d]+(\\d+)\\.?/;\nvar DATE_PARSER_REGEX = /(\\d+)[^\\d]*(\\d+)?[^\\d]*(\\d+)?\\.?/; // Internet Explorer returns non-printing characters when formatting a date\n\nvar stripExtras = function stripExtras(str) {\n  return str.replace(/\\u200E/g, '');\n};\n\nvar extractDateParts = function extractDateParts(matchResult) {\n  return matchResult // Get the 3 capture groups\n  .splice(1, 4) // Convert them to numbers\n  .map(function (datePart) {\n    return parseInt(datePart, 10);\n  });\n};\n\n/**\n * Creates a date parser function for a specific locale. The function will\n * either return a valid Date from the input or an Invalid Date object if the\n * input is invalid.\n *\n * @param locale - A BCP 47 language tag\n * @returns DateParser\n */\nexport var createDateParser = function createDateParser(locale) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n  var dateFormatter = Intl.DateTimeFormat(normalizedLocale); // Generate a date string from a hard coded date, this allows us to determine\n  // the year/month/day position for the provided locale.\n\n  var rawDateString = dateFormatter.format(INVARIANT_DATE);\n  var shortDate = stripExtras(rawDateString); // Extract the date pieces from the locale formatted date string\n\n  var formatMatch = shortDate.match(FORMAT_EXTRACTOR_REGEX);\n\n  if (!formatMatch) {\n    throw new Error('Unable to create DateParser');\n  }\n\n  var formatParts = extractDateParts(formatMatch); // Find the year/month/day positions of the locale formatted invariant date\n\n  var yearPosition = formatParts.indexOf(INVARIANT.year);\n  var monthPosition = formatParts.indexOf(INVARIANT.month);\n  var dayPosition = formatParts.indexOf(INVARIANT.day);\n  return function (date) {\n    var dateMatch = stripExtras(date).match(DATE_PARSER_REGEX);\n\n    if (!dateMatch) {\n      return INVALID_DATE;\n    }\n\n    var dateParts = extractDateParts(dateMatch); // Use the previously extracted year/month/day positions to extract each\n    // date piece.\n\n    var extractedDate = {\n      year: dateParts[yearPosition],\n      month: dateParts[monthPosition],\n      day: dateParts[dayPosition]\n    };\n    var normalizedDate = normalizeDate(extractedDate);\n\n    if (!isValid(normalizedDate)) {\n      return INVALID_DATE;\n    }\n\n    return toDate(normalizedDate);\n  };\n};"]},"metadata":{},"sourceType":"module"}