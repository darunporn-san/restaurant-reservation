{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { normalizeLocale } from '../common';\nimport { createDateParser } from '../date-parser';\nimport { toFormattedParts } from './toFormattedParts';\nexport var createLocalizationProvider = function createLocalizationProvider(locale, formatterOptions) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n\n  var formatDate = function formatDate(date) {\n    return Intl.DateTimeFormat(normalizedLocale).format(date);\n  };\n\n  var formatTime = function formatTime(date) {\n    return Intl.DateTimeFormat(normalizedLocale, {\n      hour: 'numeric',\n      minute: 'numeric'\n    }).format(date);\n  };\n\n  var getDaysShort = function getDaysShort() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var dayFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      weekday: 'short'\n    }); // Right now there is no way to find out first day of the week based on Intl (locale)\n    // api. Check issue here: https://github.com/tc39/ecma402/issues/6\n    // So we rotate the weekdays based on #weekStartDay parameter.\n\n    var weekdays = [0, 1, 2, 3, 4, 5, 6];\n    var rotatedWeekdays = weekStartDay > 0 ? [].concat(_toConsumableArray(weekdays.slice(weekStartDay)), _toConsumableArray(weekdays.slice(0, weekStartDay))) : weekdays;\n    return rotatedWeekdays.map(function (day) {\n      return (// Some short days are longer than 3 characters but are unique if the first\n        // three non-white characters are used.\n        dayFormatter // Date range chosen which has a Sun-Sat range so we can extract the names\n        .format(new Date(2000, 9, day + 1, 12)) // \\u200E matches on the Left-to-Right Mark character in IE/Edge\n        .replace(/[\\s\\u200E]/g, '').substring(0, 3)\n      );\n    });\n  };\n\n  var getMonthsLong = function getMonthsLong() {\n    var monthFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      month: 'long'\n    });\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function (month) {\n      return (// Date chosen for no real reason, the only important part is the month\n        // Using 2020 'cos Safari has a faulty implementation when we use the year 2000\n        // Intl.DateTimeFormat(\"en-US\", { month: 'long'}).format(new Date(2000, 3, 1))\n        // should give \"April\" but gives \"March\" in Safari\n        monthFormatter.format(new Date(2020, month, 1))\n      );\n    });\n  };\n\n  var parseDate = function parseDate(date) {\n    return createDateParser(normalizedLocale)(date);\n  };\n\n  var formatToParts = function formatToParts() {\n    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n    var formatter = new Intl.DateTimeFormat(normalizedLocale, formatterOptions);\n    /**\n     * Safari has a bug that returns the wrong month for years 2005 and before.\n     * The error occurs when the passed date has been created with numbers, like new Date(2000, 3, 1)\n     * Not all the months fail in each year. To ensure the correct output,\n     * we select 2020 as the base year for the whole date,\n     * then we replace in the result the original input year\n     */\n\n    var fixedDate = new Date(date);\n    fixedDate.setFullYear(2020);\n    var fixedParts = toFormattedParts(formatter.formatToParts(fixedDate));\n    var originalParts = toFormattedParts(formatter.formatToParts(date));\n\n    if (fixedParts.year) {\n      fixedParts.year = originalParts.year;\n    }\n    /**\n     * Chrome has a bug that returns hour=\"00\" when it's 12:00pm in certain languages\n     * We fix it by detecting the real time with getHours method\n     */\n\n\n    if (fixedParts.hour === '00' && fixedDate.getHours() === 12) {\n      fixedParts.hour = '12';\n    }\n\n    return fixedParts;\n  };\n\n  return {\n    getDaysShort: getDaysShort,\n    getMonthsLong: getMonthsLong,\n    formatDate: formatDate,\n    formatTime: formatTime,\n    parseDate: parseDate,\n    formatToParts: formatToParts\n  };\n};","map":{"version":3,"sources":["/Users/dsmint/restaurantreservation/node_modules/@atlaskit/locale/dist/esm/internal/localization-provider/localization-provider.js"],"names":["_toConsumableArray","normalizeLocale","createDateParser","toFormattedParts","createLocalizationProvider","locale","formatterOptions","normalizedLocale","formatDate","date","Intl","DateTimeFormat","format","formatTime","hour","minute","getDaysShort","weekStartDay","arguments","length","undefined","dayFormatter","weekday","weekdays","rotatedWeekdays","concat","slice","map","day","Date","replace","substring","getMonthsLong","monthFormatter","month","parseDate","formatToParts","formatter","fixedDate","setFullYear","fixedParts","originalParts","year","getHours"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { normalizeLocale } from '../common';\nimport { createDateParser } from '../date-parser';\nimport { toFormattedParts } from './toFormattedParts';\nexport var createLocalizationProvider = function createLocalizationProvider(locale, formatterOptions) {\n  // Intl.DateFormat expects locales in the format of 'la-CO' however it is\n  // common for locale to be provided in the format of 'la_CO', where 'la' is\n  // language and 'CO' is country.\n  var normalizedLocale = normalizeLocale(locale);\n\n  var formatDate = function formatDate(date) {\n    return Intl.DateTimeFormat(normalizedLocale).format(date);\n  };\n\n  var formatTime = function formatTime(date) {\n    return Intl.DateTimeFormat(normalizedLocale, {\n      hour: 'numeric',\n      minute: 'numeric'\n    }).format(date);\n  };\n\n  var getDaysShort = function getDaysShort() {\n    var weekStartDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var dayFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      weekday: 'short'\n    }); // Right now there is no way to find out first day of the week based on Intl (locale)\n    // api. Check issue here: https://github.com/tc39/ecma402/issues/6\n    // So we rotate the weekdays based on #weekStartDay parameter.\n\n    var weekdays = [0, 1, 2, 3, 4, 5, 6];\n    var rotatedWeekdays = weekStartDay > 0 ? [].concat(_toConsumableArray(weekdays.slice(weekStartDay)), _toConsumableArray(weekdays.slice(0, weekStartDay))) : weekdays;\n    return rotatedWeekdays.map(function (day) {\n      return (// Some short days are longer than 3 characters but are unique if the first\n        // three non-white characters are used.\n        dayFormatter // Date range chosen which has a Sun-Sat range so we can extract the names\n        .format(new Date(2000, 9, day + 1, 12)) // \\u200E matches on the Left-to-Right Mark character in IE/Edge\n        .replace(/[\\s\\u200E]/g, '').substring(0, 3)\n      );\n    });\n  };\n\n  var getMonthsLong = function getMonthsLong() {\n    var monthFormatter = Intl.DateTimeFormat(normalizedLocale, {\n      month: 'long'\n    });\n    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function (month) {\n      return (// Date chosen for no real reason, the only important part is the month\n        // Using 2020 'cos Safari has a faulty implementation when we use the year 2000\n        // Intl.DateTimeFormat(\"en-US\", { month: 'long'}).format(new Date(2000, 3, 1))\n        // should give \"April\" but gives \"March\" in Safari\n        monthFormatter.format(new Date(2020, month, 1))\n      );\n    });\n  };\n\n  var parseDate = function parseDate(date) {\n    return createDateParser(normalizedLocale)(date);\n  };\n\n  var formatToParts = function formatToParts() {\n    var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n    var formatter = new Intl.DateTimeFormat(normalizedLocale, formatterOptions);\n    /**\n     * Safari has a bug that returns the wrong month for years 2005 and before.\n     * The error occurs when the passed date has been created with numbers, like new Date(2000, 3, 1)\n     * Not all the months fail in each year. To ensure the correct output,\n     * we select 2020 as the base year for the whole date,\n     * then we replace in the result the original input year\n     */\n\n    var fixedDate = new Date(date);\n    fixedDate.setFullYear(2020);\n    var fixedParts = toFormattedParts(formatter.formatToParts(fixedDate));\n    var originalParts = toFormattedParts(formatter.formatToParts(date));\n\n    if (fixedParts.year) {\n      fixedParts.year = originalParts.year;\n    }\n    /**\n     * Chrome has a bug that returns hour=\"00\" when it's 12:00pm in certain languages\n     * We fix it by detecting the real time with getHours method\n     */\n\n\n    if (fixedParts.hour === '00' && fixedDate.getHours() === 12) {\n      fixedParts.hour = '12';\n    }\n\n    return fixedParts;\n  };\n\n  return {\n    getDaysShort: getDaysShort,\n    getMonthsLong: getMonthsLong,\n    formatDate: formatDate,\n    formatTime: formatTime,\n    parseDate: parseDate,\n    formatToParts: formatToParts\n  };\n};"]},"metadata":{},"sourceType":"module"}