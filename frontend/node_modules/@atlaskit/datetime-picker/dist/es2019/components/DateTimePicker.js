import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React from 'react';
import styled from '@emotion/styled'; // eslint-disable-next-line no-restricted-imports

import { format, isValid, parse } from 'date-fns';
import pick from 'lodash/pick';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import SelectClearIcon from '@atlaskit/icon/glyph/select-clear';
import { mergeStyles } from '@atlaskit/select';
import * as colors from '@atlaskit/theme/colors';
import { borderRadius, gridSize } from '@atlaskit/theme/constants';
import { defaultTimes, formatDateTimeZoneIntoIso } from '../internal';
import DatePicker from './DatePicker';
import TimePicker from './TimePicker';
const packageName = "@atlaskit/datetime-picker";
const packageVersion = "10.2.1";
/* eslint-disable react/no-unused-prop-types */

const getBorder = ({
  appearance,
  isFocused,
  isInvalid
}) => {
  let color = colors.N20;

  if (appearance === 'subtle') {
    color = 'transparent';
  }

  if (isFocused) {
    color = colors.B100;
  }

  if (isInvalid) {
    color = colors.R400;
  }

  return `border: 2px solid ${color};`;
};

const getBorderColorHover = ({
  isFocused,
  isInvalid,
  isDisabled
}) => {
  let color = colors.N30;

  if (isFocused || isDisabled) {
    return ``;
  }

  if (isInvalid) {
    color = colors.R400;
  }

  return `border-color: ${color};`;
};

const getBackgroundColor = ({
  appearance,
  isFocused
}) => {
  let color = colors.N20;

  if (isFocused) {
    color = colors.N0;
  }

  if (appearance === 'subtle') {
    color = 'transparent';
  }

  return `background-color: ${color};`;
};

const getBackgroundColorHover = ({
  isFocused,
  isInvalid,
  isDisabled
}) => {
  let color = colors.N30;

  if (isFocused || isDisabled) {
    return ``;
  }

  if (isInvalid) {
    color = colors.N0;
  }

  return `background-color: ${color};`;
};

const Flex = styled.div`
  ${getBackgroundColor}
  ${getBorder}
  border-radius: ${borderRadius()}px;
  display: flex;
  transition: background-color 200ms ease-in-out, border-color 200ms ease-in-out;
  &:hover {
    cursor: ${props => props.isDisabled ? 'default' : 'pointer'};
    ${getBackgroundColorHover}
    ${getBorderColorHover}
  }
`; // Make DatePicker 50% the width of DateTimePicker
// If rendering an icon container, shrink the TimePicker

const DatePickerContainer = styled.div`
  flex-basis: 50%;
  flex-grow: 1;
  flex-shrink: 0;
`;
const TimePickerContainer = styled.div`
  flex-basis: 50%;
  flex-grow: 1;
`;
const ICON_PADDING = 2;
const IconContainer = styled.div`
  flex-basis: inherit;
  padding-left: ${ICON_PADDING * 2}px;
  padding-right: ${gridSize()}px;
  padding-top: 6px;
  padding-bottom: 6px;
  display: flex;
  align-items: center;
  color: ${colors.N70};
  transition: color 150ms;
  &:hover {
    color: ${colors.N500};
  }
`; // react-select overrides (via @atlaskit/select).

const styles = {
  control: style => ({ ...style,
    backgroundColor: 'transparent',
    border: 2,
    borderRadius: 0,
    paddingLeft: 0,
    ':hover': {
      backgroundColor: 'transparent',
      cursor: 'inherit'
    }
  })
};
const dateTimePickerDefaultProps = {
  appearance: 'default',
  autoFocus: false,
  isDisabled: false,
  name: '',
  onBlur: event => {},
  onChange: value => {},
  onFocus: event => {},
  innerProps: {},
  id: '',
  defaultValue: '',
  timeIsEditable: false,
  isInvalid: false,
  datePickerProps: {},
  timePickerProps: {},
  datePickerSelectProps: {},
  timePickerSelectProps: {},
  times: defaultTimes,
  spacing: 'default',
  locale: 'en-US' // Not including a default prop for value as it will
  // Make the component a controlled component

};

class DateTimePicker extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      active: 0,
      dateValue: '',
      isFocused: false,
      timeValue: '',
      value: this.props.defaultValue,
      zoneValue: ''
    });

    _defineProperty(this, "getSafeState", () => {
      const mappedState = { ...this.state,
        ...pick(this.props, ['value'])
      };
      return { ...mappedState,
        ...this.parseValue(mappedState.value, mappedState.dateValue, mappedState.timeValue, mappedState.zoneValue)
      };
    });

    _defineProperty(this, "onBlur", event => {
      this.setState({
        isFocused: false
      });
      this.props.onBlur(event);
    });

    _defineProperty(this, "onFocus", event => {
      this.setState({
        isFocused: true
      });
      this.props.onFocus(event);
    });

    _defineProperty(this, "onDateChange", dateValue => {
      this.onValueChange({ ...this.getSafeState(),
        dateValue
      });
    });

    _defineProperty(this, "onTimeChange", timeValue => {
      this.onValueChange({ ...this.getSafeState(),
        timeValue
      });
    });

    _defineProperty(this, "onClear", () => {
      this.onValueChange({ ...this.getSafeState(),
        timeValue: '',
        dateValue: ''
      });
    });
  }

  parseValue(value, dateValue, timeValue, zoneValue) {
    if (this.props.parseValue) {
      return this.props.parseValue(value, dateValue, timeValue, zoneValue);
    }

    const parsed = parse(value);
    const valid = isValid(parsed);
    return valid ? {
      dateValue: format(parsed, 'YYYY-MM-DD'),
      timeValue: format(parsed, 'HH:mm'),
      zoneValue: format(parsed, 'ZZ')
    } : {
      dateValue,
      timeValue,
      zoneValue
    };
  }

  onValueChange({
    dateValue,
    timeValue,
    zoneValue
  }) {
    this.setState({
      dateValue,
      timeValue,
      zoneValue
    });

    if (dateValue && timeValue) {
      const value = formatDateTimeZoneIntoIso(dateValue, timeValue, zoneValue);
      const {
        zoneValue: parsedZone
      } = this.parseValue(value, dateValue, timeValue, zoneValue);
      const valueWithValidZone = formatDateTimeZoneIntoIso(dateValue, timeValue, parsedZone);
      this.setState({
        value: valueWithValidZone
      });
      this.props.onChange(valueWithValidZone); // If the date or time value was cleared when there is an existing datetime value, then clear the value.
    } else if (this.getSafeState().value) {
      this.setState({
        value: ''
      });
      this.props.onChange('');
    }
  }

  render() {
    const {
      autoFocus,
      id,
      innerProps,
      isDisabled,
      name,
      timeIsEditable,
      dateFormat,
      datePickerProps,
      datePickerSelectProps,
      timePickerProps,
      timePickerSelectProps,
      times,
      timeFormat,
      locale,
      testId
    } = this.props;
    const {
      isFocused,
      value,
      dateValue,
      timeValue
    } = this.getSafeState();
    const bothProps = {
      isDisabled,
      onBlur: this.onBlur,
      onFocus: this.onFocus,
      isInvalid: this.props.isInvalid,
      appearance: this.props.appearance,
      spacing: this.props.spacing
    };
    const {
      styles: datePickerStyles = {}
    } = datePickerSelectProps;
    const {
      styles: timePickerStyles = {}
    } = timePickerSelectProps;
    const mergedDatePickerSelectProps = { ...datePickerSelectProps,
      styles: mergeStyles(styles, datePickerStyles)
    };
    const mergedTimePickerSelectProps = { ...timePickerSelectProps,
      styles: mergeStyles(styles, timePickerStyles)
    }; // Render DateTimePicker's IconContainer when a value has been filled
    // Don't use Date or TimePicker's because they can't be customised

    const isClearable = Boolean(dateValue || timeValue);
    return /*#__PURE__*/React.createElement(Flex, _extends({}, innerProps, {
      isFocused: isFocused,
      isDisabled: isDisabled,
      isInvalid: this.props.isInvalid,
      appearance: this.props.appearance
    }), /*#__PURE__*/React.createElement("input", {
      name: name,
      type: "hidden",
      value: value
    }), /*#__PURE__*/React.createElement(DatePickerContainer, null, /*#__PURE__*/React.createElement(DatePicker, _extends({}, bothProps, {
      autoFocus: autoFocus,
      dateFormat: dateFormat,
      hideIcon: true,
      id: id,
      onChange: this.onDateChange,
      selectProps: mergedDatePickerSelectProps,
      value: dateValue,
      locale: locale,
      testId: testId && `${testId}--datepicker`
    }, datePickerProps))), /*#__PURE__*/React.createElement(TimePickerContainer, null, /*#__PURE__*/React.createElement(TimePicker, _extends({}, bothProps, {
      hideIcon: true,
      onChange: this.onTimeChange,
      selectProps: mergedTimePickerSelectProps,
      value: timeValue,
      timeIsEditable: timeIsEditable,
      times: times,
      timeFormat: timeFormat,
      locale: locale,
      testId: testId && `${testId}--timepicker`
    }, timePickerProps))), isClearable ?
    /*#__PURE__*/
    // eslint-disable-next-line styled-components-a11y/click-events-have-key-events,styled-components-a11y/no-static-element-interactions
    React.createElement(IconContainer, {
      onClick: this.onClear,
      "data-testid": testId && `${testId}--icon--container`
    }, /*#__PURE__*/React.createElement(SelectClearIcon, {
      size: "small",
      primaryColor: "inherit",
      label: "clear"
    })) : null);
  }

}

_defineProperty(DateTimePicker, "defaultProps", dateTimePickerDefaultProps);

export { DateTimePicker as DateTimePickerWithoutAnalytics };
export default withAnalyticsContext({
  componentName: 'dateTimePicker',
  packageName,
  packageVersion
})(withAnalyticsEvents({
  onChange: createAndFireEvent('atlaskit')({
    action: 'changed',
    actionSubject: 'dateTimePicker',
    attributes: {
      componentName: 'dateTimePicker',
      packageName,
      packageVersion
    }
  })
})(DateTimePicker));