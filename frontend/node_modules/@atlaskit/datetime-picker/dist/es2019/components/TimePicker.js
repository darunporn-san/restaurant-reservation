import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";
import React from 'react'; // eslint-disable-next-line no-restricted-imports

import { format, isValid } from 'date-fns';
import pick from 'lodash/pick';
import { createAndFireEvent, withAnalyticsContext, withAnalyticsEvents } from '@atlaskit/analytics-next';
import { createLocalizationProvider } from '@atlaskit/locale';
import Select, { components, CreatableSelect, mergeStyles } from '@atlaskit/select';
import { B100 } from '@atlaskit/theme/colors';
import { gridSize } from '@atlaskit/theme/constants';
import { defaultTimeFormat, defaultTimes, DropdownIndicator, EmptyClearIndicator, placeholderDatetime } from '../internal';
import FixedLayer from '../internal/FixedLayer';
import parseTime from '../internal/parseTime';
const packageName = "@atlaskit/datetime-picker";
const packageVersion = "10.2.1";
const menuStyles = {
  /* Need to remove default absolute positioning as that causes issues with position fixed */
  position: 'static',

  /* Need to add overflow to the element with max-height, otherwise causes overflow issues in IE11 */
  overflowY: 'auto',

  /* React-Popper has already offset the menu so we need to reset the margin, otherwise the offset value is doubled */
  margin: 0
};

const FixedLayerMenu = ({
  selectProps,
  ...rest
}) => /*#__PURE__*/React.createElement(FixedLayer, {
  inputValue: selectProps.inputValue,
  containerRef: selectProps.fixedLayerRef,
  content: /*#__PURE__*/React.createElement(components.Menu, _extends({}, rest, {
    menuShouldScrollIntoView: false
  })),
  testId: selectProps.testId
});

const timePickerDefaultProps = {
  appearance: 'default',
  autoFocus: false,
  defaultIsOpen: false,
  defaultValue: '',
  hideIcon: false,
  id: '',
  innerProps: {},
  isDisabled: false,
  isInvalid: false,
  name: '',
  onBlur: event => {},
  onChange: value => {},
  onFocus: event => {},
  parseInputValue: (time, timeFormat) => parseTime(time),
  selectProps: {},
  spacing: 'default',
  times: defaultTimes,
  timeIsEditable: false,
  locale: 'en-US' // Not including a default prop for value as it will
  // Make the component a controlled component

};

class TimePicker extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "containerRef", null);

    _defineProperty(this, "state", {
      isOpen: this.props.defaultIsOpen,
      clearingFromIcon: false,
      value: this.props.defaultValue,
      isFocused: false,
      l10n: createLocalizationProvider(this.props.locale)
    });

    _defineProperty(this, "getSafeState", () => {
      return { ...this.state,
        ...pick(this.props, ['value', 'isOpen'])
      };
    });

    _defineProperty(this, "onChange", (v, action) => {
      const value = v ? v.value : '';
      let changedState = {
        value
      };

      if (action && action.action === 'clear') {
        changedState = { ...changedState,
          clearingFromIcon: true
        };
      }

      this.setState(changedState);
      this.props.onChange(value);
    });

    _defineProperty(this, "onCreateOption", inputValue => {
      if (this.props.timeIsEditable) {
        const {
          parseInputValue,
          timeFormat
        } = this.props; // TODO parseInputValue doesn't accept `timeFormat` as an function arg yet...

        const value = format(parseInputValue(inputValue, timeFormat || defaultTimeFormat), 'HH:mm') || '';
        this.setState({
          value
        });
        this.props.onChange(value);
      } else {
        this.onChange(inputValue);
      }
    });

    _defineProperty(this, "onMenuOpen", () => {
      // Don't open menu after the user has clicked clear
      if (this.getSafeState().clearingFromIcon) {
        this.setState({
          clearingFromIcon: false
        });
      } else {
        this.setState({
          isOpen: true
        });
      }
    });

    _defineProperty(this, "onMenuClose", () => {
      // Don't close menu after the user has clicked clear
      if (this.getSafeState().clearingFromIcon) {
        this.setState({
          clearingFromIcon: false
        });
      } else {
        this.setState({
          isOpen: false
        });
      }
    });

    _defineProperty(this, "setContainerRef", ref => {
      const oldRef = this.containerRef;
      this.containerRef = ref; // Cause a re-render if we're getting the container ref for the first time
      // as the layered menu requires it for dimension calculation

      if (oldRef == null && ref != null) {
        this.forceUpdate();
      }
    });

    _defineProperty(this, "onBlur", event => {
      this.setState({
        isFocused: false
      });
      this.props.onBlur(event);
    });

    _defineProperty(this, "onFocus", event => {
      this.setState({
        isFocused: true
      });
      this.props.onFocus(event);
    });

    _defineProperty(this, "onSelectKeyDown", event => {
      const {
        key
      } = event;
      const keyPressed = key.toLowerCase();

      if (this.getSafeState().clearingFromIcon && (keyPressed === 'backspace' || keyPressed === 'delete')) {
        // If being cleared from keyboard, don't change behaviour
        this.setState({
          clearingFromIcon: false
        });
      }
    });

    _defineProperty(this, "getSubtleControlStyles", selectStyles => !selectStyles.control ? {
      border: `2px solid ${this.getSafeState().isFocused ? `${B100}` : `transparent`}`,
      backgroundColor: 'transparent',
      padding: '1px'
    } : {});

    _defineProperty(this, "formatTime", time => {
      const {
        formatDisplayLabel,
        timeFormat
      } = this.props;
      const {
        l10n
      } = this.getSafeState();

      if (formatDisplayLabel) {
        return formatDisplayLabel(time, timeFormat || defaultTimeFormat);
      }

      const date = parseTime(time);

      if (!(date instanceof Date)) {
        return '';
      }

      if (!isValid(date)) {
        return time;
      }

      if (timeFormat) {
        return format(date, timeFormat);
      }

      return l10n.formatTime(date);
    });

    _defineProperty(this, "getPlaceholder", () => {
      const {
        placeholder
      } = this.props;

      if (placeholder) {
        return placeholder;
      }

      const {
        l10n
      } = this.getSafeState();
      return l10n.formatTime(placeholderDatetime);
    });
  }

  componentWillReceiveProps(nextProps) {
    if (this.props.locale !== nextProps.locale) {
      this.setState({
        l10n: createLocalizationProvider(nextProps.locale)
      });
    }
  } // All state needs to be accessed via this function so that the state is mapped from props
  // correctly to allow controlled/uncontrolled usage.


  getOptions() {
    return this.props.times.map(time => {
      return {
        label: this.formatTime(time),
        value: time
      };
    });
  }

  render() {
    const {
      autoFocus,
      hideIcon,
      id,
      innerProps,
      isDisabled,
      name,
      selectProps,
      spacing,
      testId
    } = this.props;
    const ICON_PADDING = 2;
    const BORDER_WIDTH = 2;
    const {
      value = '',
      isOpen
    } = this.getSafeState();
    const validationState = this.props.isInvalid ? 'error' : 'default';
    const {
      styles: selectStyles = {},
      ...otherSelectProps
    } = selectProps;
    const controlStyles = this.props.appearance === 'subtle' ? this.getSubtleControlStyles(selectStyles) : {};
    const SelectComponent = this.props.timeIsEditable ? CreatableSelect : Select;
    const labelAndValue = value && {
      label: this.formatTime(value),
      value
    };
    const selectComponents = {
      DropdownIndicator,
      Menu: FixedLayerMenu
    };

    if (hideIcon) {
      selectComponents.ClearIndicator = EmptyClearIndicator;
    }

    const renderIconContainer = Boolean(hideIcon && value);
    const mergedStyles = mergeStyles(selectStyles, {
      control: base => ({ ...base,
        ...controlStyles
      }),
      menu: base => ({ ...base,
        ...menuStyles,
        ...{
          // Fixed positioned elements no longer inherit width from their parent, so we must explicitly set the
          // menu width to the width of our container
          width: this.containerRef ? this.containerRef.getBoundingClientRect().width : 'auto'
        }
      }),
      indicatorsContainer: base => ({ ...base,
        paddingLeft: renderIconContainer ? ICON_PADDING : 0,
        paddingRight: renderIconContainer ? gridSize() - BORDER_WIDTH : 0
      })
    });
    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/no-static-element-interactions
      React.createElement("div", _extends({}, innerProps, {
        ref: this.setContainerRef,
        "data-testid": testId && `${testId}--container`,
        onKeyDown: this.onSelectKeyDown
      }), /*#__PURE__*/React.createElement("input", {
        name: name,
        type: "hidden",
        value: value
      }), /*#__PURE__*/React.createElement(SelectComponent, _extends({
        autoFocus: autoFocus,
        components: selectComponents,
        instanceId: id,
        isClearable: true,
        isDisabled: isDisabled,
        menuIsOpen: isOpen && !isDisabled,
        menuPlacement: "auto",
        openMenuOnFocus: true,
        onBlur: this.onBlur,
        onCreateOption: this.onCreateOption,
        onChange: this.onChange,
        options: this.getOptions(),
        onFocus: this.onFocus,
        onMenuOpen: this.onMenuOpen,
        onMenuClose: this.onMenuClose,
        placeholder: this.getPlaceholder(),
        styles: mergedStyles,
        value: labelAndValue,
        spacing: spacing,
        fixedLayerRef: this.containerRef,
        validationState: validationState,
        testId: testId
      }, otherSelectProps)))
    );
  }

}

_defineProperty(TimePicker, "defaultProps", timePickerDefaultProps);

export { TimePicker as TimePickerWithoutAnalytics };
export default withAnalyticsContext({
  componentName: 'timePicker',
  packageName,
  packageVersion
})(withAnalyticsEvents({
  onChange: createAndFireEvent('atlaskit')({
    action: 'selectedTime',
    actionSubject: 'timePicker',
    attributes: {
      componentName: 'timePicker',
      packageName,
      packageVersion
    }
  })
})(TimePicker));